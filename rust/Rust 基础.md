# Rust 基础

## 变量与常量

### 变量

- 在 rust 中使用 let 关键字定义一个变量，变量默认是不可变的。
- 当一个变量不可变时，一旦被绑定到某个值上，这个值就再也无法改变。

  ```rust
  let x = 5;
  println!("{}", x);
  x = 6; // 错误： cannot assign twice to immutable variable
  println!("{}", x);
  ```

- 可以使用 mut 关键字让一个变量变成可变的。

  ```rust
  let mut x = 5;
  println!("{}", x);
  x = 6;
  println!("{}", x);
  ```

### 常量（constant）

- 在 rust 中使用 const 关键字定义一个变量。
- 绑定到常量上的值无法被其他代码修改。
- 不能使用 mut 来修饰一个常量。
- 在声明时必须显示的标注值的类型。
- 使用以下画线分隔的 全大写字母来命名一个常量。
- 常量可以声明在任何作用域中，常量在整个程序运行的过程中都在自己声明的作用域内有效。
- 只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。
  ```rust
  const MAX_POINTS: u32 = 100_000;
  ```

### 隐藏（shadow）

- 一个新声明的变量可以覆盖掉旧的同名变量，在 rust 中这个现象描述为：第一个变量被第二个变量隐藏（shadow）了。
- 由于重复使用 let 关键字会创建出新的变量，所以我们可以在复用变量名称的同时改变它的类型。
  ```rust
  let x = 5;
  let x = x + 1;
  let x = x + 1;
  println!("{}", x);
  ```

## 数据类型

### 标量类型（scalar）

标量类型是单个值类型的统称。Rust 中内建了 4 种基础的标量类型：整数、浮点数、布尔值、字符。

#### 整数类型

- `u`开头：无符号整数类型。
- `i`开头：有符号整数类型。
- 有符号和无符号代表了一个整数类型是否拥有描述负数的能力。
- isize 和 usize 两种特殊的整数类型，它们的长度取决于程序运行的目标平台。在 64 位架构上，它们就是 64 位的，而在 32 位架构上，它们就是 32 位的。
- 在 Rust 中，默认会将整数字面量的类型推导为 i32。

| 长度   | 有符号 | 无符号 |
| ------ | ------ | ------ |
| 8-bit  | i8     | u8     |
| 16-bit | i16    | u16    |
| 32-bit | i32    | u32    |
| 64-bit | i64    | u64    |
| arch   | isize  | usize  |

**注：**

- 除了 Byte，其余所有的字面量都可以使用类型后缀，比如 57u8，代表一个使用了 u8 类型的整数 57。
- 也可以使用`_`作为分隔符以方 便读数，比如 1_000。

| 整数字面量        | 示例      |
| ----------------- | --------- |
| Decimal（十进制） | 98_222    |
| Hex（十六进制）   | 0xff      |
| Octal（八进制）   | 0o77      |
| Binary（二进制）  | 0b111_000 |
| Byte              | b"A"      |

**整数溢出**

Rust 会在溢出发生时执行二进制补码环绕。任何超出类型最大值的数值都会被“环绕”为类型最小值。以 u8 为例，256 会变为 0，257 会变为 1，以此类推。

#### 浮点数类型

- Rust 还提供了两种基础的浮点数类型：f32、f64；它们分别占用 32 位和 64 位空间。
- 在 Rust 中，默认会将浮点数字面量的类型推导为 f64。

#### 数值运算

- Rust 支持常见的数学运算：加法（+）、减法（-）、乘法（\*）、除法（/）、取余（%）。

```rust
let sum = 0.1 + 0.2;
let difference = 95.5 - 4.3;
let product = 4 * 30;
let quotient = 56.7 / 32.2;
let remainder = 43 % 5;
```

#### 布尔值

- Rust 的布尔类型（bool）只拥有两个可能的值：true 和 false。

#### 字符类型

- Rust 中，char 类型被用于描述语言中最基础的单个字符。
- char 类型使用单引号指定，而不同于字符串使用双引号指定。
- Rust 中的 char 类型占 4 字节，是一个 Unicode 标量值，这也意味着它可以表示比 ASCII 多得多的字符内容。

```rust
let c = 'Z';
```

### 复合类型（compound）

复合类型 （compound type）可以将多个不同类型的值组合为一个类型。

Rust 提供了两种内置的基础复合类型：元组 （tuple）和数组 （array）。

#### 元组类型

- 创建元组需要把一系列的值使用逗号分隔后放置到一对圆括号中。
- 可以将其它不同类型的多个值组合进一个复合类型中。
- 元组拥有固定的长度，无法在声明结束后增加或减少其中的元素数量。
- 可以使用结构或者通过索引并使用点号来访问元组中的值。

```rust
// 定义元组
let tup = (35, 0.6, 1);
// 结构元组
let (x, y, z) = tup;
println!("y:{}", y);
// 点号语法
println!("z:{}", tup.2);
```

#### 数组类型

- 数组中的每一个元素都必须是相同的类型。
- 数组拥有固定的长度，无法在声明结束后增加或减少其中的元素数量。
- 可以使用逗号分隔的值放置在一对方括号内来创建一个数组。
- 可以通过索引来访问数组组中的值。

```rust
let a = [1, 2, 3, 4, 5];
let b = [3; 5]; // 等价于 let b = [3, 3, 3, 3, 3];
println!("0:{}", a[0]);
```

## 函数

- Rust 中，函数定义以 fn 关键字开始并紧随函数名称与一对圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方。
- Rust 代码使用蛇形命名法 （snake case）来作为规范函数和变量名称的风格。蛇形命名法只使用小写的字母进行命名，并以下画线分隔单词。
- Rust 不关心你在何处定义函数，只要这些定义对于使用区域是可见的即可。

```rust
fn main() {
    another_function();
}

fn another_function() {
    println!("another_function");
}
```

### 函数参数（parameter）

- 可以在函数声明中定义参数（parameter），它们是一种特殊的变量，并被视作函数签名的一部分。
- 当函数存在参数时，需要在调用函数时为这些变量提供具体的值。
- 参数变量称为形参（parameter）。
- 传入的具体参数值称为实参（argument）。
- 可以通过使用逗号分隔符来为函数声明多个参数。
- 在函数签名中，你必须显式地声明每个参数的类型。

```rust
fn main() {
    // 函数参数
    another_function(30, 20)
}

fn another_function(x: i32, y: i32) {
    println!("和：{}", x + y);
}
```

### 函数中的语句和表达式

- 函数体由若干条语句组成，并可以以一个表达式作为结尾。
- 由于 Rust 是一门基于表达式的语言，所以它将语句（statement）与表达式（expression）区别为两个不同的概念。
- 语句指那些执行操作但不返回值的指令。
- 表达式则是指会进行计算并产生一个值作为结果的指令。

### 函数的返回值

- 在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。
- 也可以使用 return 关键字并指定一个值来提前从函数中返回。
- 需要在箭头符号（->）的后面声明它的类型。

```rust
fn main() {
    // 函数返回值
    println!("{}", five());
}

fn five() -> i32 {
    5
}
```

## 控制流

### if 表达式

- if 表达式允许我们根据条件执行不同的代码分支。
- 所有的 if 表达式都会使用 if 关键字来开头，并紧随一个判断条件。
- Rust 不会自动尝试将非布尔类型的值转换为布尔类型。
- 你必须显式地在 if 表达式中提供一个布尔类型作为条件。
- 如果使用了多余一个的 else if，那么最好使用 match 来重构代码。

```rust
fn main() {
    // if表达式
    let number = 3;

    if number < 5 && number > 0 {
        println!("true!");
    } else if number > 10 {
        println!("false")
    } else {
        println!("")
    }
}
```

### let if

- 由于 if 是一个表达式，所以我们可以在 let 语句的右侧使用它来生成一个值。
- 代码块输出的值就是其中最后一个表达式的值。
- 数字本身也可以作为一个表达式使用。
- 变量只能拥有单一的类型。

```rust
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "six" // Error: `if` and `else` have incompatible types
    }
}
```

## 循环

Rust 提供了 3 种循环：loop、while 和 for。

### loop 循环

- loop 循环可以使用 break 来结束循环。
- loop 循环中可以将要返回的值添加到 break 表达式的后面。

```rust
let mut counter = 0;

let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};

println!("The result is {}", result)
```

### while 循环

- while 会在条件为真时重复执行代码。

```rust
let mut number = 3;

while number != 0 {
    println!("{}!", number);
    number -= 1;
}

println!("LIFTOFF!!!")
```

### for 循环

- 使用 for 循环遍历集合中的每个元素。

  ```rust
  let a = [10, 20, 30, 40, 50];

  for element in a.iter() {
      println!("the value is: {}", element);
  }
  ```

- 使用 for 循环循环特定次数的任务。

  ```rust
  for number in (1..4).rev() {
      println!("{}!", number)
  }

  println!("LIFTOFF!!!")
  ```

## 所有权

- Rust 使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何的运行时开销。

### 所有权规则

- Rust 中的每一个值都有一个对应的变量作为它的所有者。
- 在同一时间内，只能有一个所有者。
- 当所有者离开自己的作用域时，它持有的值就会被释放掉。

### 变量作用域

**Rust 会在作用域结束的地方自动调用 drop 函数。**

```Rust
{
                        // 由于变量s还未被声明，所以它在这里是不可用的
    let s = "hello";    // 从这里开始变量s变得可用
    // 执行与 s 相关的操作
}                       // 作用域到这里结束，变量 s 再次不可用
```
